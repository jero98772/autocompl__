<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Autocomplete</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        input { width: 300px; padding: 10px; font-size: 16px; }
        ul { list-style: none; padding: 0; max-height: 200px; overflow-y: auto; }
        li { padding: 5px 10px; border-bottom: 1px solid #eee; }
        li:hover { background: #f0f0f0; cursor: pointer; }
        #error, #status { margin: 10px 0; }
        #error { color: red; }
        #status { color: green; }
    </style>
</head>
<body>
    <h1>Real-Time Autocomplete</h1>
    <input type="text" id="search" placeholder="Type a word..." autocomplete="off" />
    <div id="status"></div>
    <div id="error"></div>
    <ul id="suggestions"></ul>

    <script>
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEndOfWord = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }

    insert(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char);
        }
        node.isEndOfWord = true;
    }

    searchPrefix(prefix) {
        let node = this.root;
        for (const char of prefix) {
            if (!node.children.has(char)) {
                return null;
            }
            node = node.children.get(char);
        }
        return node;
    }

    autocomplete(prefix, maxResults = 10) {
        const results = [];
        const node = this.searchPrefix(prefix);
        if (!node) return results;

        const dfs = (currentNode, currentWord) => {
            if (results.length >= maxResults) return;

            if (currentNode.isEndOfWord) {
                results.push(currentWord);
            }

            for (const [char, childNode] of currentNode.children) {
                if (results.length < maxResults) {
                    dfs(childNode, currentWord + char);
                }
            }
        };

        dfs(node, prefix);
        return results;
    }
}

const trie = new Trie();
const errorDiv = document.getElementById("error");
const statusDiv = document.getElementById("status");

async function loadWordsFromFile(filePath) {
    try {
        const response = await fetch(filePath);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const text = await response.text();
        const words = text.split(/\r?\n/);
        words.forEach(word => {
            if (word.trim()) trie.insert(word.trim().toLowerCase());
        });
        console.log(`Loaded ${words.length} words into Trie`);
        errorDiv.textContent = `Loaded ${words.length} words successfully`;
    } catch (error) {
        console.error("Error loading words:", error);
        errorDiv.textContent = `Error loading words: ${error.message}. Ensure words.txt exists in the same directory.`;
    }
}

// Load words from words.txt
//loadWordsFromFile("words.txt");
//loadWordsFromFile("words_en.txt");
//loadWordsFromFile("words_ge.txt");
let completedFiles = 0;
const files = ['words.txt', 'words_en.txt', 'words_ge.txt'];
for (var i = files.length - 1; i >= 0; i--) {
    statusDiv.textContent = `Loaded ${completedFiles}/${files.length} word files`;
    loadWordsFromFile(files[i]);
    completedFiles++;
}
statusDiv.textContent = `Loaded ${completedFiles}/${files.length} word files`;

const inputField = document.getElementById("search");
const suggestionsList = document.getElementById("suggestions");

inputField.addEventListener("input", () => {
    const query = inputField.value.toLowerCase().trim();
    suggestionsList.innerHTML = "";

    if (query.length > 1) {
        const suggestions = trie.autocomplete(query);
        suggestions.forEach(word => {
            const li = document.createElement("li");
            li.textContent = word;
            li.addEventListener("click", () => {
                inputField.value = word;
                suggestionsList.innerHTML = "";
            });
            suggestionsList.appendChild(li);
        });
    }
});
    </script>
</body>
</html>